"
elements := #(1 3 5 6 9).
odds := OrderedCollection  new.index := 1.
[index <= elements size] whileTrue: [( ( elements  at: index ) odd ) ifTrue: [odds add:(elements  at: index )].
    index:= index +1.
    ].
odds   
"

" el at no sirve en un conjunto pero si en una coleccion de este estilo "
" esto es una chanchada es lo hice porque no conozco como funciona la coleccion "
"

elements := #(1 3 5 6 9).
odds := OrderedCollection  new.
elements do: [ :each | (each odd) ifTrue: [odds add: each ]
        ].
   
    odds
"
    "y si quiero filtrar ? el conjunto no emplementa ni el array implementa el filtrado  pero como estas cosas son colecciones saben como filtrarse pero no como recorrerse "

"array no tiene un select sino que lo hereda de collection  lo que hace select es crear un array nuevo e ir llenandolo con las cosas que tiene "  
 #(1 3 5 6 4 9)[: element | (element odd) ].
 
"select filtra por una condicion, devuelve los que cumplen esa condicion si ninguno cumple devuelve el vacio"

 #(1 3 5 6 4 9 10 15 54 888 77849 165798498 9849817192  99811791929729 9197895954654) select: [:element | (element odd) ]
 
" el doble del conjunto "

#(1 3 5 6 4 9) collect: [:element | (element*2)]

"OJO AL PIOJO  multiplico al "
#(-1 -3 5 6 4 9) collect: [:element | (element*2)]

#(-1 -3 5 6 4 9) collect: [:element | (element*element)] 

"encontrar el primer par , detect  devuelve un elemento de la coleccion no una coleccion con un solo elemento"

#(-1 2 -3 5 9) detect: [:element | (element even)]

"y si no tiene par ?  tira error  para eso ponemo if NOne:  y lo que queremos que pasa "
#(-1 -3 5 9) detect: [:element | (element even)] ifNone:[self error: 'no encontre nada tamo al horno ']

" el mensaje aca se llama  detect: ifNone:  lo otro son los colaboradores pero el nombre se llama detect: ifNone lo que aparece en celestito es el mensaje "

" no vamos a usar el detect porque esto tira error cuando no encuentra nada  vamos a usar detect: ifNone"

"sumar  los elementos de un array
el inyect par ser un acumulador tiene que empezar en 0 y luego 
inyectemos un 0 en una suma de 0 en el siguiente elemento y asi iterando 
" 

#(1 3 5 6 4 9) inject: 0 into: [:suma :element | suma + element]


"inyectar el doble " 

#(1 3 5 6 4 9) inject: 0 into: [:suma :element | suma + (element*2)]


'ihhhisnindfiuhseihuiwwqasdihaso' select: [:char | char isVowel ]
"
'ihhhisnindfiuhseihuiwwqasdihaso' collect: [:char |
	char class numericValue: 
	char +1]

esto no funciona 
ariante 5, librasfuerzas kilogramofuerza
"
10*peso
"objeto 10 recive mensaje * con el colaborador peso "
10*dollar
10*euro 
"10*peso + 10*dollar  problema de precedencia  por lo que hace flatan los parentesis "
(10*peso)+(10*dollar)
"este si funciona " 
(10*peso)+(10*dollar)+(50*peso)
"tambien suma  y puedo quedarme solo con dolares "
(10*peso)+(10*dollar)+(50*peso)-(60*peso)
"el peso es un objeto definido por uno de los paquetes que viene con cuis como una unidad de medida simple "

(10*peso) amount
(10*second) unit 
10 amount 
10 unit

(10*peso) + 50

metro := BaseUnit nameForOne: 'metro' nameForMany: 'metros'.
diezMetros  := metro with: 10.



metros := BaseUnit  nameForOne: 'metro' nameForMany:'metros'.
diezMetros := metros with: 10.
"
pulgadas := BaseUnit nameForOne: 'pulgada' nameForMany: 'pulgadas'.
sesentaPulgadas := pulgadas with: 60.
"
centimetro := ProportionalDerivedUnit  baseUnit: metros conversionFactor: 1/100  nameForOne: 'centimetro' nameForMany: 'centimetros'  sign: 'cm'.

diezMetros  convertTo: centimetro.

" ahora en vez de definir las pulgadas podemos definir a las pulgadas enbase a los centimetros  o a los metros "

pulgadas := ProportionalDerivedUnit baseUnit: metros conversionFactor: 0.0254 nameForOne: 'pulgada'  nameForMany: 'pulgadas' sign: 'in'.

diezMetros convertTo:  pulgadas 


metros := BaseUnit  nameForOne: 'metro' nameForMany:'metros'.
diezMetros := metros with: 10.
"
pulgadas := BaseUnit nameForOne: 'pulgada' nameForMany: 'pulgadas'.
sesentaPulgadas := pulgadas with: 60.
"
centimetro := ProportionalDerivedUnit  baseUnit: metros conversionFactor: 1/100  nameForOne: 'centimetro' nameForMany: 'centimetros'  sign: 'cm'.

diezMetros  convertTo: centimetro.

" ahora en vez de definir las pulgadas podemos definir a las pulgadas enbase a los centimetros  o a los metros "

pulgadas := ProportionalDerivedUnit baseUnit: metros conversionFactor: 0.0254 nameForOne: 'pulgada'  nameForMany: 'pulgadas' sign: 'in'.

diezMetros convertTo:  pulgadas 







